#
# Autogenerated by Thrift
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Types;

# HELPER FUNCTIONS AND STRUCTURES

package RushHour_registerClient_args;
use Class::Accessor;
use base('Class::Accessor');
RushHour_registerClient_args->mk_accessors( qw( email name ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{email} = undef;
$self->{name} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{email}) {
      $self->{email} = $vals->{email};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'RushHour_registerClient_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{email});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_registerClient_args');
  if (defined $self->{email}) {
    $xfer += $output->writeFieldBegin('email', TType::STRING, 1);
    $xfer += $output->writeString($self->{email});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_registerClient_result;
use Class::Accessor;
use base('Class::Accessor');
RushHour_registerClient_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{dee} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{dee}) {
      $self->{dee} = $vals->{dee};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'RushHour_registerClient_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{dee} = new DuplicateEmailException();
        $xfer += $self->{dee}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_registerClient_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{dee}) {
    $xfer += $output->writeFieldBegin('dee', TType::STRUCT, 1);
    $xfer += $self->{dee}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_canMove_args;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'RushHour_canMove_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_canMove_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_canMove_result;
use Class::Accessor;
use base('Class::Accessor');
RushHour_canMove_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{goe} = undef;
$self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{goe}) {
      $self->{goe} = $vals->{goe};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'RushHour_canMove_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{goe} = new GameOverException();
        $xfer += $self->{goe}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new UnregisteredException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_canMove_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{goe}) {
    $xfer += $output->writeFieldBegin('goe', TType::STRUCT, 1);
    $xfer += $self->{goe}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 2);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_takeRoad_args;
use Class::Accessor;
use base('Class::Accessor');
RushHour_takeRoad_args->mk_accessors( qw( road speed ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{road} = undef;
$self->{speed} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{road}) {
      $self->{road} = $vals->{road};
    }
    if (defined $vals->{speed}) {
      $self->{speed} = $vals->{speed};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'RushHour_takeRoad_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{road} = new Road();
        $xfer += $self->{road}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{speed});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_takeRoad_args');
  if (defined $self->{road}) {
    $xfer += $output->writeFieldBegin('road', TType::STRUCT, 1);
    $xfer += $self->{road}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{speed}) {
    $xfer += $output->writeFieldBegin('speed', TType::DOUBLE, 2);
    $xfer += $output->writeDouble($self->{speed});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_takeRoad_result;
use Class::Accessor;
use base('Class::Accessor');
RushHour_takeRoad_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{nmme} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{nmme}) {
      $self->{nmme} = $vals->{nmme};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'RushHour_takeRoad_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{nmme} = new NoMoveMadeException();
        $xfer += $self->{nmme}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_takeRoad_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nmme}) {
    $xfer += $output->writeFieldBegin('nmme', TType::STRUCT, 1);
    $xfer += $self->{nmme}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_getRoadConditions_args;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'RushHour_getRoadConditions_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_getRoadConditions_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_getRoadConditions_result;
use Class::Accessor;
use base('Class::Accessor');
RushHour_getRoadConditions_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{nmme} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{nmme}) {
      $self->{nmme} = $vals->{nmme};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'RushHour_getRoadConditions_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new RoadMap();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{nmme} = new NoMoveMadeException();
        $xfer += $self->{nmme}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_getRoadConditions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nmme}) {
    $xfer += $output->writeFieldBegin('nmme', TType::STRUCT, 1);
    $xfer += $self->{nmme}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_getIntersectionsFromRoad_args;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'RushHour_getIntersectionsFromRoad_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_getIntersectionsFromRoad_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_getIntersectionsFromRoad_result;
use Class::Accessor;
use base('Class::Accessor');
RushHour_getIntersectionsFromRoad_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'RushHour_getIntersectionsFromRoad_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new IntersectionsFromRoad();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_getIntersectionsFromRoad_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_winGame_args;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'RushHour_winGame_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_winGame_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_winGame_result;
use Class::Accessor;
use base('Class::Accessor');
RushHour_winGame_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
$self->{ue} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{ue}) {
      $self->{ue} = $vals->{ue};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'RushHour_winGame_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ue} = new UnregisteredException();
        $xfer += $self->{ue}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_winGame_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ue}) {
    $xfer += $output->writeFieldBegin('ue', TType::STRUCT, 1);
    $xfer += $self->{ue}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_getTime_args;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'RushHour_getTime_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_getTime_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_getTime_result;
use Class::Accessor;
use base('Class::Accessor');
RushHour_getTime_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'RushHour_getTime_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_getTime_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::DOUBLE, 0);
    $xfer += $output->writeDouble($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_getCurrentIntersection_args;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'RushHour_getCurrentIntersection_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_getCurrentIntersection_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_getCurrentIntersection_result;
use Class::Accessor;
use base('Class::Accessor');
RushHour_getCurrentIntersection_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'RushHour_getCurrentIntersection_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Intersection();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_getCurrentIntersection_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_getScoreBoard_args;
use Class::Accessor;
use base('Class::Accessor');
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
return bless($self,$classname);
}

sub getName {
  return 'RushHour_getScoreBoard_args';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_getScoreBoard_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHour_getScoreBoard_result;
use Class::Accessor;
use base('Class::Accessor');
RushHour_getScoreBoard_result->mk_accessors( qw( success ) );
sub new {
my $classname = shift;
my $self      = {};
my $vals      = shift || {};
$self->{success} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
  }
return bless($self,$classname);
}

sub getName {
  return 'RushHour_getScoreBoard_result';
}

sub read {
  my $self  = shift;
  my $input = shift;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my $self   = shift;
  my $output = shift;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('RushHour_getScoreBoard_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRING, 0);
    $xfer += $output->writeString($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package RushHourIf;

sub registerClient{
  my $self = shift;
  my $email = shift;
  my $name = shift;

  die 'implement interface';
}
sub canMove{
  my $self = shift;

  die 'implement interface';
}
sub takeRoad{
  my $self = shift;
  my $road = shift;
  my $speed = shift;

  die 'implement interface';
}
sub getRoadConditions{
  my $self = shift;

  die 'implement interface';
}
sub getIntersectionsFromRoad{
  my $self = shift;

  die 'implement interface';
}
sub winGame{
  my $self = shift;

  die 'implement interface';
}
sub getTime{
  my $self = shift;

  die 'implement interface';
}
sub getCurrentIntersection{
  my $self = shift;

  die 'implement interface';
}
sub getScoreBoard{
  my $self = shift;

  die 'implement interface';
}
package RushHourRest;

sub new {
  my $classname=shift;
  my $impl     =shift;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub registerClient{
  my $self = shift;
  my $request = shift;

  my $email = ($request->{'email'}) ? $request->{'email'} : undef;
  my $name = ($request->{'name'}) ? $request->{'name'} : undef;
  return $self->{impl}->registerClient($email, $name);
}

sub canMove{
  my $self = shift;
  my $request = shift;

  return $self->{impl}->canMove();
}

sub takeRoad{
  my $self = shift;
  my $request = shift;

  my $road = ($request->{'road'}) ? $request->{'road'} : undef;
  my $speed = ($request->{'speed'}) ? $request->{'speed'} : undef;
  return $self->{impl}->takeRoad($road, $speed);
}

sub getRoadConditions{
  my $self = shift;
  my $request = shift;

  return $self->{impl}->getRoadConditions();
}

sub getIntersectionsFromRoad{
  my $self = shift;
  my $request = shift;

  return $self->{impl}->getIntersectionsFromRoad();
}

sub winGame{
  my $self = shift;
  my $request = shift;

  return $self->{impl}->winGame();
}

sub getTime{
  my $self = shift;
  my $request = shift;

  return $self->{impl}->getTime();
}

sub getCurrentIntersection{
  my $self = shift;
  my $request = shift;

  return $self->{impl}->getCurrentIntersection();
}

sub getScoreBoard{
  my $self = shift;
  my $request = shift;

  return $self->{impl}->getScoreBoard();
}

package RushHourClient;

use base('RushHourIf');
sub new {
  my $classname = shift;
  my $input     = shift;
  my $output    = shift;
  my $self      = {};
    $self->{input}  = $input;
    $self->{output} = defined $output ? $output : $input;
    $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub registerClient{
  my $self = shift;
  my $email = shift;
  my $name = shift;

    $self->send_registerClient($email, $name);
  return $self->recv_registerClient();
}

sub send_registerClient{
  my $self = shift;
  my $email = shift;
  my $name = shift;

  $self->{output}->writeMessageBegin('registerClient', TMessageType::CALL, $self->{seqid});
  my $args = new RushHour_registerClient_args();
  $args->{email} = $email;
  $args->{name} = $name;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_registerClient{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new RushHour_registerClient_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{dee}) {
    die $result->{dee};
  }
  die "registerClient failed: unknown result";
}
sub canMove{
  my $self = shift;

    $self->send_canMove();
  return $self->recv_canMove();
}

sub send_canMove{
  my $self = shift;

  $self->{output}->writeMessageBegin('canMove', TMessageType::CALL, $self->{seqid});
  my $args = new RushHour_canMove_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_canMove{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new RushHour_canMove_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{goe}) {
    die $result->{goe};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  die "canMove failed: unknown result";
}
sub takeRoad{
  my $self = shift;
  my $road = shift;
  my $speed = shift;

    $self->send_takeRoad($road, $speed);
  return $self->recv_takeRoad();
}

sub send_takeRoad{
  my $self = shift;
  my $road = shift;
  my $speed = shift;

  $self->{output}->writeMessageBegin('takeRoad', TMessageType::CALL, $self->{seqid});
  my $args = new RushHour_takeRoad_args();
  $args->{road} = $road;
  $args->{speed} = $speed;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_takeRoad{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new RushHour_takeRoad_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{nmme}) {
    die $result->{nmme};
  }
  die "takeRoad failed: unknown result";
}
sub getRoadConditions{
  my $self = shift;

    $self->send_getRoadConditions();
  return $self->recv_getRoadConditions();
}

sub send_getRoadConditions{
  my $self = shift;

  $self->{output}->writeMessageBegin('getRoadConditions', TMessageType::CALL, $self->{seqid});
  my $args = new RushHour_getRoadConditions_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRoadConditions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new RushHour_getRoadConditions_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{nmme}) {
    die $result->{nmme};
  }
  die "getRoadConditions failed: unknown result";
}
sub getIntersectionsFromRoad{
  my $self = shift;

    $self->send_getIntersectionsFromRoad();
  return $self->recv_getIntersectionsFromRoad();
}

sub send_getIntersectionsFromRoad{
  my $self = shift;

  $self->{output}->writeMessageBegin('getIntersectionsFromRoad', TMessageType::CALL, $self->{seqid});
  my $args = new RushHour_getIntersectionsFromRoad_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getIntersectionsFromRoad{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new RushHour_getIntersectionsFromRoad_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getIntersectionsFromRoad failed: unknown result";
}
sub winGame{
  my $self = shift;

    $self->send_winGame();
  return $self->recv_winGame();
}

sub send_winGame{
  my $self = shift;

  $self->{output}->writeMessageBegin('winGame', TMessageType::CALL, $self->{seqid});
  my $args = new RushHour_winGame_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_winGame{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new RushHour_winGame_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{ue}) {
    die $result->{ue};
  }
  die "winGame failed: unknown result";
}
sub getTime{
  my $self = shift;

    $self->send_getTime();
  return $self->recv_getTime();
}

sub send_getTime{
  my $self = shift;

  $self->{output}->writeMessageBegin('getTime', TMessageType::CALL, $self->{seqid});
  my $args = new RushHour_getTime_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getTime{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new RushHour_getTime_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getTime failed: unknown result";
}
sub getCurrentIntersection{
  my $self = shift;

    $self->send_getCurrentIntersection();
  return $self->recv_getCurrentIntersection();
}

sub send_getCurrentIntersection{
  my $self = shift;

  $self->{output}->writeMessageBegin('getCurrentIntersection', TMessageType::CALL, $self->{seqid});
  my $args = new RushHour_getCurrentIntersection_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getCurrentIntersection{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new RushHour_getCurrentIntersection_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getCurrentIntersection failed: unknown result";
}
sub getScoreBoard{
  my $self = shift;

    $self->send_getScoreBoard();
  return $self->recv_getScoreBoard();
}

sub send_getScoreBoard{
  my $self = shift;

  $self->{output}->writeMessageBegin('getScoreBoard', TMessageType::CALL, $self->{seqid});
  my $args = new RushHour_getScoreBoard_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getScoreBoard{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new RushHour_getScoreBoard_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  die "getScoreBoard failed: unknown result";
}
package RushHourProcessor;

sub new {
    my $classname = shift;
    my $handler   = shift;
    my $self      = {};
    $self->{handler} = $handler;
    return bless($self,$classname);
}

sub process {
    my $self   = shift;
    my $input  = shift;
    my $output = shift;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!method_exists($self, $methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
  }

sub process_registerClient{
    my $self = shift;
    my ($seqid, $input, $output); 
    my $args = new RushHour_registerClient_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new RushHour_registerClient_result();
    eval {
      $result->{success} = $self->{handler}->registerClient($args->email, $args->name);
    }; if( UNIVERSAL::isa($@,'DuplicateEmailException') ){ 
      $result->{dee} = $@;
    }
    $output->writeMessageBegin('registerClient', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->getTransport()->flush();
}
sub process_canMove{
  my $self = shift;
  my ($seqid, $input, $output); 
  my $args = new RushHour_canMove_args();
  $args->read($input);
  $input->readMessageEnd();
  my $result = new RushHour_canMove_result();
  eval {
    $result->{success} = $self->{handler}->canMove();
  }; if( UNIVERSAL::isa($@,'GameOverException') ){ 
    $result->{goe} = $@;
    }; if( UNIVERSAL::isa($@,'UnregisteredException') ){ 
    $result->{ue} = $@;
  }
  $output->writeMessageBegin('canMove', TMessageType::REPLY, $seqid);
  $result->write($output);
  $output->getTransport()->flush();
}
sub process_takeRoad{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new RushHour_takeRoad_args();
$args->read($input);
$input->readMessageEnd();
my $result = new RushHour_takeRoad_result();
eval {
  $result->{success} = $self->{handler}->takeRoad($args->road, $args->speed);
}; if( UNIVERSAL::isa($@,'NoMoveMadeException') ){ 
  $result->{nmme} = $@;
}
$output->writeMessageBegin('takeRoad', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_getRoadConditions{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new RushHour_getRoadConditions_args();
$args->read($input);
$input->readMessageEnd();
my $result = new RushHour_getRoadConditions_result();
eval {
$result->{success} = $self->{handler}->getRoadConditions();
}; if( UNIVERSAL::isa($@,'NoMoveMadeException') ){ 
$result->{nmme} = $@;
}
$output->writeMessageBegin('getRoadConditions', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_getIntersectionsFromRoad{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new RushHour_getIntersectionsFromRoad_args();
$args->read($input);
$input->readMessageEnd();
my $result = new RushHour_getIntersectionsFromRoad_result();
$result->{success} = $self->{handler}->getIntersectionsFromRoad();
$output->writeMessageBegin('getIntersectionsFromRoad', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_winGame{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new RushHour_winGame_args();
$args->read($input);
$input->readMessageEnd();
my $result = new RushHour_winGame_result();
eval {
$result->{success} = $self->{handler}->winGame();
}; if( UNIVERSAL::isa($@,'UnregisteredException') ){ 
$result->{ue} = $@;
}
$output->writeMessageBegin('winGame', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_getTime{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new RushHour_getTime_args();
$args->read($input);
$input->readMessageEnd();
my $result = new RushHour_getTime_result();
$result->{success} = $self->{handler}->getTime();
$output->writeMessageBegin('getTime', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_getCurrentIntersection{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new RushHour_getCurrentIntersection_args();
$args->read($input);
$input->readMessageEnd();
my $result = new RushHour_getCurrentIntersection_result();
$result->{success} = $self->{handler}->getCurrentIntersection();
$output->writeMessageBegin('getCurrentIntersection', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
sub process_getScoreBoard{
my $self = shift;
my ($seqid, $input, $output); 
my $args = new RushHour_getScoreBoard_args();
$args->read($input);
$input->readMessageEnd();
my $result = new RushHour_getScoreBoard_result();
$result->{success} = $self->{handler}->getScoreBoard();
$output->writeMessageBegin('getScoreBoard', TMessageType::REPLY, $seqid);
$result->write($output);
$output->getTransport()->flush();
}
1;
